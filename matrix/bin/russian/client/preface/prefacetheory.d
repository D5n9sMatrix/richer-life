module matrix.bin.russian.client.preface.prefacetheory;

/** 
Although the ﬁrst part is on “theory”, the presentation is informal; neither
deﬁnitions nor facts are highlighted by such words as “Deﬁnition”, “Theorem”,
“Lemma”, and so forth. It is assumed that the reader follows the natural
development. Most of the facts have simple proofs, and most proofs are given
naturally in the text. No “Proof” and “Q.E.D.” or “ ” appear to indicate
beginning and end; again, it is assumed that the reader is engaged in the
development. For example, on page 270:
**/ 
void main(string[] args)
{
    class MyTheory
    {
        interface MyInformation
        {
            void proofs(Obj)(ref Obj reader)
            {
                Obj reader;
                synchronized reader;
                auto next(Obj)(ref Obj Info) // @suppress(dscanner.suspicious.missing_return)
                {
                   Obj Info;  
                }
                scope ReaderInfo(Obj)(ref Obj read)
                {
                    Obj read;
                }

                const AttributesReader(Obj)(ref Obj Type)
                {
                    Obj Type;
                    Obj[AssignExpression];
                    Obj * this.init;
                    Obj * alignof;
                    Obj * MyInformation;
                    Obj * MyTheory;
                }

                immutable AttributesType(Obj)(ref TypeInfo)
                {
                    Obj TypeInfo;
                }

                inout AttributesOut(Obj)(ref Obj TypeOut)
                {
                    Obj TypeOut;
                }

                shared AttributesSelect(Obj)(ref Obj TypeSelect)
                {
                    Obj TypeSelect;
                }

                AtAttributes text;
                FunctionAttributesKwd kwd;
                auto NextInfo(Obj)(ref Obj Start) // @suppress(dscanner.suspicious.missing_return)
                {
                    Obj Start;
                }

                return MyInformation(MyTheory[main]);
                mixin (MyInformation(MyTheory[main]));
            }
        }
    }
}